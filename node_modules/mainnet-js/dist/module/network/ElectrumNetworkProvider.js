import { ConnectionStatus, } from "@electrum-cash/network";
import { Network } from "../interface.js";
import { getTransactionHash } from "../util/transaction.js";
import { Config } from "../config.js";
import { decodeHeader } from "../util/header.js";
import { IndexedDbCache } from "../cache/IndexedDbCache.js";
import { WebStorageCache } from "../cache/WebStorageCache.js";
import { MemoryCache } from "../cache/MemoryCache.js";
export default class ElectrumNetworkProvider {
    get cache() {
        if (!Config.UseMemoryCache &&
            !Config.UseLocalStorageCache &&
            !Config.UseIndexedDBCache) {
            this._cache = undefined;
            return this._cache;
        }
        if (Config.UseMemoryCache && !(this._cache instanceof MemoryCache)) {
            this._cache = new IndexedDbCache();
            return this._cache;
        }
        if (Config.UseLocalStorageCache &&
            !(this._cache instanceof WebStorageCache)) {
            this._cache = new WebStorageCache();
            return this._cache;
        }
        if (Config.UseIndexedDBCache && !(this._cache instanceof IndexedDbCache)) {
            this._cache = new IndexedDbCache();
            return this._cache;
        }
        return this._cache;
    }
    constructor(electrum, network = Network.MAINNET, manualConnectionManagement) {
        this.network = network;
        this.manualConnectionManagement = manualConnectionManagement;
        this.subscriptions = 0;
        this.subscribedToHeaders = false;
        this.subscriptionMap = {};
        if (electrum) {
            this.electrum = electrum;
        }
        else {
            throw new Error(`A electrum-cash client is required.`);
        }
    }
    async getUtxos(cashaddr) {
        const result = await this.performRequest("blockchain.address.listunspent", cashaddr, "include_tokens");
        return result.map((utxo) => ({
            txid: utxo.tx_hash,
            vout: utxo.tx_pos,
            satoshis: utxo.value,
            height: utxo.height,
            token: utxo.token_data
                ? {
                    amount: BigInt(utxo.token_data.amount),
                    tokenId: utxo.token_data.category,
                    capability: utxo.token_data.nft?.capability,
                    commitment: utxo.token_data.nft?.commitment,
                }
                : undefined,
        }));
    }
    async getBalance(cashaddr) {
        const result = await this.performRequest("blockchain.address.get_balance", cashaddr);
        return result.confirmed + result.unconfirmed;
    }
    async getHeader(height, verbose = false) {
        const key = `header-${this.network}-${height}-${verbose}`;
        if (this.cache) {
            const cached = await this.cache.getItem(key);
            if (cached) {
                return verbose ? decodeHeader(JSON.parse(cached)) : JSON.parse(cached);
            }
        }
        const result = await this.performRequest("blockchain.header.get", height);
        if (this.cache) {
            await this.cache.setItem(key, JSON.stringify(result));
        }
        return verbose ? decodeHeader(result) : result;
    }
    async getBlockHeight() {
        return (await this.performRequest("blockchain.headers.get_tip"))
            .height;
    }
    async getRawTransaction(txHash, verbose = false, loadInputValues = false) {
        const key = `tx-${this.network}-${txHash}-${verbose}-${loadInputValues}`;
        if (this.cache) {
            const cached = await this.cache.getItem(key);
            if (cached) {
                return verbose ? JSON.parse(cached) : cached;
            }
        }
        try {
            const transaction = (await this.performRequest("blockchain.transaction.get", txHash, verbose));
            if (this.cache) {
                await this.cache.setItem(key, verbose
                    ? JSON.stringify(transaction)
                    : transaction);
            }
            if (verbose && loadInputValues) {
                // get unique transaction hashes
                const hashes = [...new Set(transaction.vin.map((val) => val.txid))];
                const transactions = await Promise.all(hashes.map((hash) => this.getRawTransactionObject(hash, false)));
                const transactionMap = new Map();
                transactions.forEach((val) => transactionMap.set(val.hash, val));
                transaction.vin.forEach((input) => {
                    const output = transactionMap
                        .get(input.txid)
                        .vout.find((val) => val.n === input.vout);
                    input.address = output.scriptPubKey.addresses[0];
                    input.value = output.value;
                    input.tokenData = output.tokenData;
                });
            }
            return transaction;
        }
        catch (error) {
            if (error.message.indexOf("No such mempool or blockchain transaction.") > -1)
                throw Error(`Could not decode transaction ${txHash}. It might not exist on the current blockchain (${this.network}).`);
            else
                throw error;
        }
    }
    // gets the decoded transaction in human readable form
    async getRawTransactionObject(txHash, loadInputValues = false) {
        return (await this.getRawTransaction(txHash, true, loadInputValues));
    }
    async sendRawTransaction(txHex, awaitPropagation = true) {
        return new Promise(async (resolve, reject) => {
            let txHash = await getTransactionHash(txHex);
            if (!awaitPropagation) {
                this.performRequest("blockchain.transaction.broadcast", txHex);
                resolve(txHash);
            }
            else {
                let cancel;
                const waitForTransactionCallback = async (data) => {
                    if (data && data[0] === txHash && data[1] !== null) {
                        await cancel?.();
                        resolve(txHash);
                    }
                };
                cancel = await this.subscribeToTransaction(txHash, waitForTransactionCallback);
                this.performRequest("blockchain.transaction.broadcast", txHex).catch(async (error) => {
                    await cancel?.();
                    reject(error);
                });
            }
        });
    }
    // Get transaction history of a given cashaddr
    async getHistory(cashaddr, fromHeight = 0, toHeight = -1) {
        const result = await this.performRequest("blockchain.address.get_history", cashaddr, fromHeight, toHeight);
        return result;
    }
    // Get the minimum fee a low-priority transaction must pay in order to be accepted to the daemon's memory pool.
    async getRelayFee() {
        const result = (await this.performRequest("blockchain.relayfee"));
        return result;
    }
    async watchAddressStatus(cashaddr, callback) {
        const watchAddressStatusCallback = async (data) => {
            // subscription acknowledgement is the latest known status or null if no status is known
            // status is an array: [ cashaddr, statusHash ]
            if (data instanceof Array) {
                const addr = data[0];
                if (addr !== cashaddr) {
                    return;
                }
                const status = data[1];
                callback(status);
            }
        };
        return this.subscribeToAddress(cashaddr, watchAddressStatusCallback);
    }
    async watchAddress(cashaddr, callback) {
        const historyMap = {};
        this.getHistory(cashaddr).then((history) => history.forEach((val) => (historyMap[val.tx_hash] = true)));
        const watchAddressStatusCallback = async () => {
            const newHistory = await this.getHistory(cashaddr);
            // sort history to put unconfirmed transactions in the beginning, then transactions in block height descenting order
            const txHashes = newHistory
                .sort((a, b) => a.height <= 0 || b.height <= 0 ? -1 : b.height - a.height)
                .map((val) => val.tx_hash);
            for (const hash of txHashes) {
                if (!(hash in historyMap)) {
                    historyMap[hash] = true;
                    callback(hash);
                    // exit early to prevent further map lookups
                    break;
                }
            }
        };
        return this.watchAddressStatus(cashaddr, watchAddressStatusCallback);
    }
    async watchAddressTransactions(cashaddr, callback) {
        return this.watchAddress(cashaddr, async (txHash) => {
            const tx = await this.getRawTransactionObject(txHash);
            callback(tx);
        });
    }
    async watchAddressTokenTransactions(cashaddr, callback) {
        return this.watchAddress(cashaddr, async (txHash) => {
            const tx = await this.getRawTransactionObject(txHash, true);
            if (tx.vin.some((val) => val.tokenData) ||
                tx.vout.some((val) => val.tokenData)) {
                callback(tx);
            }
        });
    }
    // watch for block headers and block height, if `skipCurrentHeight` is set, the notification about current block will not arrive
    async watchBlocks(callback, skipCurrentHeight = true) {
        let acknowledged = !skipCurrentHeight;
        const waitForBlockCallback = (_header) => {
            if (!acknowledged) {
                acknowledged = true;
                return;
            }
            _header = _header instanceof Array ? _header[0] : _header;
            callback(_header);
        };
        return this.subscribeToHeaders(waitForBlockCallback);
    }
    // Wait for the next block or a block at given blockchain height.
    async waitForBlock(height) {
        return new Promise(async (resolve) => {
            let cancelWatch;
            if (this.electrum.chainHeight && !height) {
                height = this.electrum.chainHeight + 1;
            }
            cancelWatch = await this.watchBlocks(async (header) => {
                if (!height) {
                    height = header.height + 1;
                    return;
                }
                if (header.height >= height) {
                    await cancelWatch?.();
                    resolve(header);
                    return;
                }
            });
        });
    }
    // subscribe to notifications sent when new block is found, the block header is sent to callback
    async subscribeToHeaders(callback) {
        return this.subscribeRequest("blockchain.headers.subscribe", callback);
    }
    async subscribeToAddress(cashaddr, callback) {
        return this.subscribeRequest("blockchain.address.subscribe", callback, cashaddr);
    }
    async subscribeToTransaction(txHash, callback) {
        return this.subscribeRequest("blockchain.transaction.subscribe", callback, txHash);
    }
    async performRequest(name, ...parameters) {
        await this.ready();
        const requestTimeout = new Promise(function (_resolve, reject) {
            setTimeout(function () {
                reject("electrum-cash request timed out, retrying");
            }, 30000);
        }).catch(function (e) {
            throw e;
        });
        const request = this.electrum.request(name, ...parameters);
        return await Promise.race([request, requestTimeout])
            .then((value) => {
            if (value instanceof Error)
                throw value;
            let result = value;
            return result;
        })
            .catch(async () => {
            return await Promise.race([request, requestTimeout])
                .then((value) => {
                if (value instanceof Error)
                    throw value;
                let result = value;
                return result;
            })
                .catch(function (e) {
                throw e;
            });
        });
    }
    async trackSubscription(methodName, ...parameters) {
        const key = `${methodName}-${this.network}-${JSON.stringify(parameters)}`;
        if (this.subscriptionMap[key]) {
            this.subscriptionMap[key]++;
        }
        else {
            this.subscriptionMap[key] = 1;
        }
        await this.electrum.subscribe(methodName, ...parameters);
    }
    async untrackSubscription(methodName, ...parameters) {
        const key = `${methodName}-${this.network}-${JSON.stringify(parameters)}`;
        if (this.subscriptionMap[key]) {
            this.subscriptionMap[key]--;
            if (this.subscriptionMap[key] <= 0) {
                // only really unsubscribe if there are no more subscriptions for this `key`
                delete this.subscriptionMap[key];
                try {
                    await this.electrum.unsubscribe(methodName, ...parameters);
                }
                catch { }
            }
        }
    }
    async subscribeRequest(methodName, callback, ...parameters) {
        await this.ready();
        const handler = (data) => {
            if (data.method === methodName) {
                callback(data.params);
            }
        };
        this.electrum.on("notification", handler);
        // safeguard against multiple subscriptions to headers
        if (methodName === "blockhain.headers.subscribe") {
            if (!this.subscribedToHeaders) {
                this.subscribedToHeaders = true;
                await this.trackSubscription(methodName, ...parameters);
            }
        }
        else {
            await this.trackSubscription(methodName, ...parameters);
        }
        this.subscriptions++;
        return async () => {
            this.electrum.off("notification", handler);
            this.subscriptions--;
            // there are no blockchain.headers.unsubscribe method, so let's safeguard against it
            if (methodName !== "blockchain.headers.subscribe") {
                await this.untrackSubscription(methodName, ...parameters);
            }
        };
    }
    async ready() {
        return this.connect();
    }
    async connect() {
        await this.cache?.init();
        if (this.electrum.status !== ConnectionStatus.CONNECTED) {
            await this.electrum.connect();
        }
    }
    disconnect() {
        if (this.subscriptions > 0) {
            // console.warn(
            //   `Trying to disconnect a network provider with ${this.subscriptions} active subscriptions. This is in most cases a bad idea.`
            // );
        }
        return this.electrum.disconnect(true, false);
    }
}
//# sourceMappingURL=ElectrumNetworkProvider.js.map