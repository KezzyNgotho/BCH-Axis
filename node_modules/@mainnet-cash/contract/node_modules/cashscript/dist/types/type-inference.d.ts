import type SignatureTemplate from '../SignatureTemplate.js';
type BytesType = Uint8Array | string;
type SignatureType = SignatureTemplate | BytesType;
type TypeMap = {
    [k: `bytes${number}`]: BytesType;
} & {
    byte: BytesType;
    bytes: BytesType;
    bool: boolean;
    int: bigint;
    string: string;
    pubkey: BytesType;
    sig: SignatureType;
    datasig: BytesType;
};
type ProcessParam<Param> = Param extends {
    type: infer Type;
} ? Type extends keyof TypeMap ? TypeMap[Type] : any : any;
export type ParamsToTuple<Params> = Params extends readonly [infer Head, ...infer Tail] ? [ProcessParam<Head>, ...ParamsToTuple<Tail>] : Params extends readonly [] ? [] : any[];
type ProcessFunction<Function, ReturnType> = Function extends {
    name: string;
    inputs: readonly any[];
} ? {
    [functionName in Function['name']]: (...functionParameters: ParamsToTuple<Function['inputs']>) => ReturnType;
} : {};
type InternalAbiToFunctionMap<Abi, ReturnType> = unknown extends Abi ? GenericFunctionMap<ReturnType> : Abi extends readonly [infer Head, ...infer Tail] ? ProcessFunction<Head, ReturnType> & InternalAbiToFunctionMap<Tail, ReturnType> : Abi extends readonly [] ? {} : GenericFunctionMap<ReturnType>;
type GenericFunctionMap<ReturnType> = {
    [functionName: string]: (...functionParameters: any[]) => ReturnType;
};
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
export type AbiToFunctionMap<T, ReturnType> = Prettify<InternalAbiToFunctionMap<T, ReturnType>>;
export {};
