import { binToHex, decodeTransactionUnsafe, hexToBin, isHex } from '@bitauth/libauth';
import { sha256 } from '@cashscript/utils';
import { Network } from '../interfaces.js';
import { addressToLockScript, libauthTokenDetailsToCashScriptTokenDetails, randomUtxo } from '../utils.js';
// redeclare the addresses from vars.ts instead of importing them
const aliceAddress = 'bchtest:qpgjmwev3spwlwkgmyjrr2s2cvlkkzlewq62mzgjnp';
const bobAddress = 'bchtest:qz6q5gqnxdldkr07xpls5474mmzmlesd6qnux4skuc';
const carolAddress = 'bchtest:qqsr7nqwe6rq5crj63gy5gdqchpnwmguusmr7tfmsj';
// We are setting the default updateUtxoSet to 'false' so that it doesn't break the current behaviour
// TODO: in a future breaking release we want to set this to 'true' by default
export default class MockNetworkProvider {
    constructor(options) {
        // we use lockingBytecode hex as the key for utxoMap to make cash addresses and token addresses interchangeable
        this.utxoSet = [];
        this.transactionMap = {};
        this.network = Network.MOCKNET;
        this.blockHeight = 133700;
        this.options = { updateUtxoSet: false, ...options };
        for (let i = 0; i < 3; i += 1) {
            this.addUtxo(aliceAddress, randomUtxo());
            this.addUtxo(bobAddress, randomUtxo());
            this.addUtxo(carolAddress, randomUtxo());
        }
    }
    async getUtxos(address) {
        const addressLockingBytecode = binToHex(addressToLockScript(address));
        return this.utxoSet.filter(([lockingBytecode]) => lockingBytecode === addressLockingBytecode).map(([, utxo]) => utxo);
    }
    setBlockHeight(newBlockHeight) {
        this.blockHeight = newBlockHeight;
    }
    async getBlockHeight() {
        return this.blockHeight;
    }
    async getRawTransaction(txid) {
        return this.transactionMap[txid];
    }
    async sendRawTransaction(txHex) {
        const transactionBin = hexToBin(txHex);
        const txid = binToHex(sha256(sha256(transactionBin)).reverse());
        if (this.options.updateUtxoSet && this.transactionMap[txid]) {
            throw new Error(`Transaction with txid ${txid} was already submitted`);
        }
        this.transactionMap[txid] = txHex;
        // If updateUtxoSet is false, we don't need to update the utxo set, and just return the txid
        if (!this.options.updateUtxoSet)
            return txid;
        const decodedTransaction = decodeTransactionUnsafe(transactionBin);
        decodedTransaction.inputs.forEach((input) => {
            const utxoIndex = this.utxoSet.findIndex(([, utxo]) => utxo.txid === binToHex(input.outpointTransactionHash) && utxo.vout === input.outpointIndex);
            // TODO: we should check what error a BCHN node throws, so we can throw the same error here
            if (utxoIndex === -1) {
                throw new Error(`UTXO not found for input ${input.outpointIndex} of transaction ${txid}`);
            }
            this.utxoSet.splice(utxoIndex, 1);
        });
        decodedTransaction.outputs.forEach((output, vout) => {
            this.addUtxo(binToHex(output.lockingBytecode), {
                txid,
                vout,
                satoshis: output.valueSatoshis,
                token: output.token && libauthTokenDetailsToCashScriptTokenDetails(output.token),
            });
        });
        return txid;
    }
    // Note: the user can technically add the same UTXO multiple times (txid + vout), to the same or different addresses
    // but we don't check for this in the sendRawTransaction method. We might want to prevent duplicates from being added
    // in the first place.
    addUtxo(addressOrLockingBytecode, utxo) {
        const lockingBytecode = isHex(addressOrLockingBytecode) ?
            addressOrLockingBytecode : binToHex(addressToLockScript(addressOrLockingBytecode));
        this.utxoSet.push([lockingBytecode, utxo]);
    }
    reset() {
        this.utxoSet = [];
        this.transactionMap = {};
    }
}
//# sourceMappingURL=MockNetworkProvider.js.map