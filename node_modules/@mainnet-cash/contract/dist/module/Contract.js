import { binToHex } from "@bitauth/libauth";
import { Contract as CashScriptContract, } from "cashscript";
import { compileString, compileFile } from "cashc";
import { CONST, fromUtxoId, getNetworkProvider, Mainnet, } from "mainnet-js";
import { castConstructorParametersFromArtifact, castStringArgumentsFromArtifact, transformContractToRequests, } from "./util.js";
import WrappedProvider, { toCashScript, toMainnet } from "./WrappedProvider.js";
/**
 * Class that manages the Contract source, network, parameters, CashScript artifact and calls
 */
export class Contract {
    /**
     * Initializes a Contract
     *
     * @param script The contract in CashScript syntax
     * @param parameters Stored values of a contract passed to the CashScript constructor
     * @param network Network for the contract
     * @param nonce A unique number to differentiate the contract
     *
     * @see {@link https://rest-unstable.mainnet.cash/api-docs/#/contract/createContract|/contract/create} REST endpoint
     * @returns A new contract
     */
    constructor(script, parameters, network, nonce) {
        this.script = script;
        this.parameters = parameters.map((val) => typeof val === "number" ? BigInt(val) : val);
        this.network = network ? network : "mainnet";
        this.artifact = compileString(script);
        this.provider = new WrappedProvider(getNetworkProvider(this.network));
        this.contract = this.getContractInstance();
        this.nonce = nonce ? nonce : Mainnet.getWeakRandomInt(2147483647);
    }
    getContractText() {
        return this.script;
    }
    getNonce() {
        return this.nonce;
    }
    /**
     * getSerializedScript - Serialize just the script component of a contract
     *
     * a low-level function
     *
     * @returns A serialized script
     */
    getSerializedScript() {
        return Mainnet.btoa(this.script);
    }
    /**
     * getSerializedParameters - Serialize just the parameters of a contract
     *
     * a low-level function
     *
     * @returns The serialized parameters
     */
    getSerializedParameters() {
        return Mainnet.btoa(this.parameters
            .map((a) => Mainnet.btoa(a.toString()))
            .join(CONST.DELIMITER));
    }
    /**
     * getParameterList - Get the parameters as a list
     *
     * a low-level function
     *
     * @returns A list of parameters as strings
     */
    getParameterList() {
        return this.parameters.map((x) => ArrayBuffer.isView(x) ? binToHex(new Uint8Array(x.buffer)) : x);
    }
    /**
     * toString - Serialize a contract as a string
     *
     * an intermediate function
     *
     * @returns A serialized contract
     */
    toString() {
        return [
            "contract",
            this.network,
            this.getSerializedParameters(),
            this.getSerializedScript(),
            this.getNonce(),
        ].join(CONST.DELIMITER);
    }
    /**
     * fromId - Deserialize a contract from a string
     *
     * an intermediate function
     *
     * @returns A new contract
     */
    static fromId(contractId) {
        const [type, network, serializedParams, serializedScript, nonce] = contractId.split(CONST.DELIMITER);
        const script = Mainnet.atob(serializedScript);
        const artifact = compileString(script);
        const paramStrings = Mainnet.atob(serializedParams)
            .split(CONST.DELIMITER)
            .map((s) => Mainnet.atob(s));
        const params = castConstructorParametersFromArtifact(paramStrings, artifact);
        return new Contract(script, params, network, parseInt(nonce));
    }
    /**
     * _create - Static convenience method for the constructor
     *
     * an intermediate function similar to the constructor for rest
     *
     * @see {@link https://rest-unstable.mainnet.cash/api-docs/#/contract/createContract|/contract/create} REST endpoint
     * @returns A new contract
     */
    static _create(script, parameters, network, nonce) {
        const artifact = compileString(script);
        const params = castConstructorParametersFromArtifact(parameters, artifact);
        return new this(script, params, network, nonce);
    }
    /**
     * Get the unspent transaction outputs of the contract
     *
     * an intermediate function
     *
     * @note For REST, the address is automatically returned from the create interface
     * @returns The address for a contract
     */
    getDepositAddress() {
        return this.contract.address;
    }
    /**
     * Get the unspent transaction outputs of the contract
     *
     * an intermediate function
     *
     * @note For REST, the address is automatically returned from the create interface
     * @returns The address for a contract
     */
    getTokenDepositAddress() {
        return this.contract.tokenAddress;
    }
    /**
     * Get the unspent transaction outputs of the contract
     *
     * a high-level function
     *
     * @see {@link https://rest-unstable.mainnet.cash/api-docs/#/contract/utxos} REST endpoint
     * @returns A list of utxos on the contract
     */
    async getUtxos() {
        return (await this.provider.getUtxos(this.getDepositAddress())).map(toMainnet);
    }
    /**
     * Get the current balance of the contract
     *
     * @returns The balance in satoshi
     */
    async getBalance() {
        return Number(await this.contract.getBalance());
    }
    /**
     * Get the information about the contract
     *
     * a high-level function
     *
     * @see {@link https://rest-unstable.mainnet.cash/api-docs/#/contract/info} REST endpoint
     * @returns The contract info
     */
    info() {
        return {
            contractId: this.toString(),
            cashaddr: this.contract.address,
            tokenaddr: this.contract.tokenAddress,
            script: this.script,
            parameters: this.getParameterList()
                // map bigints to numbers for REST service.
                .map((val) => (typeof val === "bigint" ? Number(val) : val)),
            nonce: this.nonce,
        };
    }
    _info() {
        return this.info();
    }
    /**
     * getContractInstance - get the object directly as a cashscript contract.
     * @returns A CashScript Contract
     */
    getContractInstance() {
        return new CashScriptContract(this.artifact, this.parameters, {
            provider: this.provider,
            addressType: "p2sh20",
        });
    }
    /**
     * fromCashScript - initialize the artifact and cashscript object from existing script
     * @returns A cashscript Contract
     */
    fromCashScript() {
        this.artifact = compileFile(this.script);
        this.contract = new CashScriptContract(this.artifact, [], {
            provider: this.provider,
            addressType: "p2sh20",
        });
        return this;
    }
    /**
     * Get a contract object from a script, arguments, network and nonce
     * @param script The contract cashscript test
     * @param parameters Contract constructor arguments
     * @param network Network for the contract
     * @param nonce A unique number to differentiate the contract
     * @returns A new Contract
     */
    static fromCashScript(script, parameters, network, nonce) {
        return new this(script, parameters, network, nonce).fromCashScript();
    }
    /**
     * getContractFunction - Get a function object from a contract
     *
     * @param funcName The string identifying the function in the cashscript contract
     * @returns A cashscript Transaction
     */
    getContractFunction(funcName) {
        return this.contract.functions[funcName];
    }
    /**
     * runFunctionFromStrings -  Call a cashscript contract function using an interface object of strings.
     *
     * This is a helper function for the REST or serialized interfaces and not intended
     * for native use within the library, although it may be useful for running stored transactions.
     *
     * @param request Parameters for the transaction call, serialized as strings.
     * @returns A CashScript Transaction result
     */
    async runFunctionFromStrings(request) {
        const fn = this.getContractFunction(request.function);
        const arg = await castStringArgumentsFromArtifact(request.arguments, this.artifact, request.function);
        let func = fn(...arg);
        func = func.to(await transformContractToRequests(request.to));
        if (request.utxoIds) {
            const utxos = request.utxoIds.map(fromUtxoId).map(toCashScript);
            func = func.from(utxos);
        }
        if (request.opReturn) {
            func = func.withOpReturn(request.opReturn);
        }
        if (request.feePerByte) {
            func = func.withFeePerByte(request.feePerByte);
        }
        if (request.hardcodedFee) {
            func = func.withHardcodedFee(BigInt(request.hardcodedFee));
        }
        if (request.minChange) {
            func = func.withMinChange(BigInt(request.minChange));
        }
        if (request.withoutChange) {
            func = func.withoutChange();
        }
        if (request.age) {
            func = func.withAge(request.age);
        }
        if (request.time) {
            func = func.withTime(request.time);
        }
        return await func[request.action]();
    }
    getFunctionByName(funcName) {
        if (typeof this.contract.functions[funcName] === "function") {
            return this.contract.functions[funcName];
        }
        else {
            throw Error(`${funcName} is not a contract method`);
        }
    }
    async estimateFee(func, publicKey, sig, outputAddress, utxos) {
        const feePerByte = 1;
        // Create an estimate transaction with zero fees, sending nominal balance
        const estimatorTransaction = func(publicKey, sig, 10n, 2147483640n)
            .to([{ to: outputAddress, amount: 1000n }])
            .from(utxos.map(toCashScript));
        const estimatedTxHex = (await estimatorTransaction
            .withHardcodedFee(500n)["build"]());
        // Use the feePerByte to get the fee for the transaction length
        return Math.round((estimatedTxHex.length / 2) * feePerByte);
    }
    /**
     * Create a new contract, but respond with a json object
     * @param request A contract request object
     * @returns A new contract object
     */
    static contractRespFromJsonRequest(request) {
        const contract = Contract._create(request.script, request.parameters, request.network);
        if (contract) {
            return {
                contractId: contract.toString(),
                cashaddr: contract.getDepositAddress(),
            };
        }
        else {
            throw Error("Error creating contract");
        }
    }
}
//# sourceMappingURL=Contract.js.map