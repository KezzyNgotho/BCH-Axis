import { binToHex, decodeTransaction, decodeTransactionUnsafe, encodeTransaction, hexToBin, } from '@bitauth/libauth';
import { isUnlockableUtxo, isStandardUnlockableUtxo, isContractUnlocker, } from './interfaces.js';
import { cashScriptOutputToLibauthOutput, createOpReturnOutput, delay, generateLibauthSourceOutputs, validateInput, validateOutput, } from './utils.js';
import { FailedTransactionError } from './Errors.js';
import { debugLibauthTemplate, getLibauthTemplate, getBitauthUri } from './libauth-template/LibauthTemplate.js';
import { getWcContractInfo } from './walletconnect-utils.js';
import semver from 'semver';
const DEFAULT_SEQUENCE = 0xfffffffe;
export class TransactionBuilder {
    constructor(options) {
        this.inputs = [];
        this.outputs = [];
        this.locktime = 0;
        this.provider = options.provider;
        this.options = {
            allowImplicitFungibleTokenBurn: options.allowImplicitFungibleTokenBurn ?? false,
            ...options,
        };
    }
    addInput(utxo, unlocker, options) {
        return this.addInputs([utxo], unlocker, options);
    }
    addInputs(utxos, unlocker, options) {
        utxos.forEach(validateInput);
        if ((!unlocker && utxos.some((utxo) => !isUnlockableUtxo(utxo)))
            || (unlocker && utxos.some((utxo) => isUnlockableUtxo(utxo)))) {
            throw new Error('Either all UTXOs must have an individual unlocker specified, or no UTXOs must have an individual unlocker specified and a shared unlocker must be provided');
        }
        if (!unlocker) {
            this.inputs = this.inputs.concat(utxos);
            return this;
        }
        this.inputs = this.inputs.concat(utxos.map(((utxo) => ({ ...utxo, unlocker, options }))));
        return this;
    }
    addOutput(output) {
        return this.addOutputs([output]);
    }
    addOutputs(outputs) {
        outputs.forEach(validateOutput);
        this.outputs = this.outputs.concat(outputs);
        return this;
    }
    // TODO: allow uint8array for chunks
    addOpReturnOutput(chunks) {
        this.outputs.push(createOpReturnOutput(chunks));
        return this;
    }
    setLocktime(locktime) {
        this.locktime = locktime;
        return this;
    }
    checkMaxFee(transaction) {
        const totalInputAmount = this.inputs.reduce((total, input) => total + input.satoshis, 0n);
        const totalOutputAmount = this.outputs.reduce((total, output) => total + output.amount, 0n);
        const fee = totalInputAmount - totalOutputAmount;
        if (this.options.maximumFeeSatoshis && fee > this.options.maximumFeeSatoshis) {
            throw new Error(`Transaction fee of ${fee} is higher than max fee of ${this.options.maximumFeeSatoshis}`);
        }
        if (this.options.maximumFeeSatsPerByte) {
            const transactionSize = encodeTransaction(transaction).byteLength;
            const feePerByte = Number((Number(fee) / transactionSize).toFixed(2));
            if (feePerByte > this.options.maximumFeeSatsPerByte) {
                throw new Error(`Transaction fee per byte of ${feePerByte} is higher than max fee per byte of ${this.options.maximumFeeSatsPerByte}`);
            }
        }
    }
    checkFungibleTokenBurn() {
        if (this.options.allowImplicitFungibleTokenBurn)
            return;
        const tokenInputAmounts = {};
        const tokenOutputAmounts = {};
        for (const input of this.inputs) {
            if (input.token?.amount) {
                tokenInputAmounts[input.token.category] = (tokenInputAmounts[input.token.category] || 0n) + input.token.amount;
            }
        }
        for (const output of this.outputs) {
            if (output.token?.amount) {
                tokenOutputAmounts[output.token.category] = (tokenOutputAmounts[output.token.category] || 0n) + output.token.amount;
            }
        }
        for (const [category, inputAmount] of Object.entries(tokenInputAmounts)) {
            const outputAmount = tokenOutputAmounts[category] || 0n;
            if (outputAmount < inputAmount) {
                throw new Error(`Implicit burning of fungible tokens for category ${category} is not allowed (input amount: ${inputAmount}, output amount: ${outputAmount}). If this is intended, set allowImplicitFungibleTokenBurn to true.`);
            }
        }
    }
    buildLibauthTransaction() {
        this.checkFungibleTokenBurn();
        const inputs = this.inputs.map((utxo) => ({
            outpointIndex: utxo.vout,
            outpointTransactionHash: hexToBin(utxo.txid),
            sequenceNumber: utxo.options?.sequence ?? DEFAULT_SEQUENCE,
            unlockingBytecode: new Uint8Array(),
        }));
        const outputs = this.outputs.map(cashScriptOutputToLibauthOutput);
        const transaction = {
            inputs,
            locktime: this.locktime,
            outputs,
            version: 2,
        };
        // Generate source outputs from inputs (for signing with SIGHASH_UTXOS)
        const sourceOutputs = generateLibauthSourceOutputs(this.inputs);
        const inputScripts = this.inputs.map((input, inputIndex) => (input.unlocker.generateUnlockingBytecode({ transaction, sourceOutputs, inputIndex })));
        inputScripts.forEach((script, i) => {
            transaction.inputs[i].unlockingBytecode = script;
        });
        this.checkMaxFee(transaction);
        return transaction;
    }
    build() {
        const transaction = this.buildLibauthTransaction();
        return binToHex(encodeTransaction(transaction));
    }
    debug() {
        if (this.inputs.some((input) => !isStandardUnlockableUtxo(input))) {
            throw new Error('Cannot debug a transaction with custom unlocker');
        }
        // We can typecast this because we check that all inputs are standard unlockable in the check above
        const contractVersions = this.inputs
            .map((input) => 'contract' in input.unlocker ? input.unlocker.contract.artifact.compiler.version : null)
            .filter((version) => version !== null);
        if (!contractVersions.every((version) => semver.satisfies(version, '>=0.11.0'))) {
            console.warn('For the best debugging experience, please recompile your contract with cashc version 0.11.0 or newer.');
        }
        return debugLibauthTemplate(this.getLibauthTemplate(), this);
    }
    getVmResourceUsage(verbose = false) {
        // Note that only StandardUnlockableUtxo inputs are supported for debugging, so any transaction with custom unlockers
        // cannot be debugged (and therefore cannot return VM resource usage)
        const results = this.debug();
        const vmResourceUsage = [];
        const tableData = [];
        const formatMetric = (value, total, withPercentage = false) => `${formatNumber(value)} / ${formatNumber(total)}${withPercentage ? ` (${(value / total * 100).toFixed(0)}%)` : ''}`;
        const formatNumber = (value) => value.toLocaleString('en');
        const resultEntries = Object.entries(results);
        for (const [index, input] of this.inputs.entries()) {
            const [, result] = resultEntries.find(([entryKey]) => entryKey.includes(`input${index}`)) ?? [];
            const metrics = result?.at(-1)?.metrics;
            // Should not happen
            if (!metrics)
                throw new Error('VM resource could not be calculated');
            vmResourceUsage.push(metrics);
            tableData.push({
                'Contract - Function': isContractUnlocker(input.unlocker) ? `${input.unlocker.contract.name} - ${input.unlocker.abiFunction.name}` : 'P2PKH Input',
                Ops: metrics.evaluatedInstructionCount,
                'Op Cost Budget Usage': formatMetric(metrics.operationCost, metrics.maximumOperationCost, true),
                SigChecks: formatMetric(metrics.signatureCheckCount, metrics.maximumSignatureCheckCount),
                Hashes: formatMetric(metrics.hashDigestIterations, metrics.maximumHashDigestIterations),
            });
        }
        if (verbose) {
            console.log('VM Resource usage by inputs:');
            console.table(tableData);
        }
        return vmResourceUsage;
    }
    getBitauthUri() {
        console.warn('WARNING: it is unsafe to use this Bitauth URI when using real private keys as they are included in the transaction template');
        return getBitauthUri(this.getLibauthTemplate());
    }
    getLibauthTemplate() {
        return getLibauthTemplate(this);
    }
    async send(raw) {
        const tx = this.build();
        // If all inputs are standard unlockable, we can debug the transaction locally
        // before sending so any errors are caught early
        if (this.inputs.every((input) => isStandardUnlockableUtxo(input))) {
            this.debug();
        }
        try {
            const txid = await this.provider.sendRawTransaction(tx);
            return raw ? await this.getTxDetails(txid, raw) : await this.getTxDetails(txid);
        }
        catch (e) {
            const reason = e.error ?? e.message;
            throw new FailedTransactionError(reason, this.getBitauthUri());
        }
    }
    async getTxDetails(txid, raw) {
        for (let retries = 0; retries < 1200; retries += 1) {
            await delay(500);
            try {
                const hex = await this.provider.getRawTransaction(txid);
                if (raw)
                    return hex;
                const libauthTransaction = decodeTransaction(hexToBin(hex));
                return { ...libauthTransaction, txid, hex };
            }
            catch (ignored) {
                // ignored
            }
        }
        // Should not happen
        throw new Error('Could not retrieve transaction details for over 10 minutes');
    }
    generateWcTransactionObject(options) {
        const encodedTransaction = this.build();
        const transaction = decodeTransactionUnsafe(hexToBin(encodedTransaction));
        const libauthSourceOutputs = generateLibauthSourceOutputs(this.inputs);
        const sourceOutputs = libauthSourceOutputs.map((sourceOutput, index) => {
            return {
                ...sourceOutput,
                ...transaction.inputs[index],
                ...getWcContractInfo(this.inputs[index]),
            };
        });
        return { ...options, transaction, sourceOutputs };
    }
}
//# sourceMappingURL=TransactionBuilder.js.map