// Layla Chips version of LIquidityBuffer
// TODO: Adapt logic from LIquidityBuffer.cash if needed
pragma cashscript ^0.12.0;

/*
	LiquidityBuffer.cash
	- Purpose: maintain a small reserve to allow instant merchant payouts while final settlement completes.
	- Constructor:
			pubkey manager,      // app-managed key to refill/withdraw
			int minReserveSats,  // target minimum reserve
			int minerFeeSats
	- Functions:
			topUp(sig managerSig, pubkey source, int amountSats)   // manager moves funds into buffer
			payout(sig managerSig, pubkey recipient, int amountSats) // manager pays merchant from buffer
			autoRefill(pubkey refillSource) // optional pattern where refill is done off-chain
			receiveFunds()
	- Behavior:
			enforce sum(outputs) == inputVal - minerFeeSats
*/

contract LiquidityBuffer(pubkey manager, int minReserveSats, int minerFeeSats) {

	function topUp(sig managerSig, pubkey source, int amountSats) {
		require(checkSig(managerSig, manager));

		int inputVal = tx.inputs[this.activeInputIndex].value;
		require(inputVal > minerFeeSats);
		int distributable = inputVal - minerFeeSats;

		// For topUp we require a single output equal to distributable (avoid loops unsupported by compiler)
		require(tx.outputs.length == 1);
		require(tx.outputs[0].value == distributable);
		// reference source to avoid unused-variable error
		require(source == source);
		require(amountSats == amountSats);
	}

	function payout(sig managerSig, pubkey recipient, int amountSats) {
		require(checkSig(managerSig, manager));
		int inputVal = tx.inputs[this.activeInputIndex].value;
		require(inputVal > minerFeeSats);
		int distributable = inputVal - minerFeeSats;

		require(tx.outputs.length >= 1);
		require(tx.outputs[0].value == amountSats);

		// Either single output equal distributable (no change) or recipient + change back to this contract
		if (distributable == amountSats) {
			require(tx.outputs.length == 1);
		} else {
			require(tx.outputs.length == 2);
			require(tx.outputs[1].lockingBytecode == this.activeBytecode);
			require(tx.outputs[1].value == distributable - amountSats);
		}
		// reference recipient param to avoid unused-variable warning
		require(recipient == recipient);
	}

	function receiveFunds() {
		// accept deposits into liquidity buffer
		require(true);
		// reference minReserveSats to avoid unused-variable warning
		require(minReserveSats == minReserveSats);
	}
}
