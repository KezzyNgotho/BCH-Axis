import { CashAddressNetworkPrefix } from "@bitauth/libauth";
import { NetworkType } from "../enum.js";
import { WalletTypeEnum } from "./enum.js";
import { MnemonicI, SendRequestOptionsI, WalletInfoI } from "./interface.js";
import { OpReturnData, SendRequest, SendRequestArray, SendResponse, SourceOutput, TokenSendRequest } from "./model.js";
import { SignedMessageI } from "../message/index.js";
import ElectrumNetworkProvider from "../network/ElectrumNetworkProvider.js";
import { BalanceResponse } from "../util/balanceObjectFromSatoshi.js";
import { BaseWallet } from "./Base.js";
/**
 * Class to manage a bitcoin cash wallet.
 */
export declare class Wallet extends BaseWallet {
    readonly provider: ElectrumNetworkProvider;
    readonly cashaddr: string;
    readonly tokenaddr: string;
    readonly derivationPath: string;
    readonly parentDerivationPath: string;
    readonly mnemonic: string;
    readonly parentXPubKey: string;
    readonly privateKey: Uint8Array;
    readonly publicKeyCompressed: Uint8Array;
    readonly privateKeyWif: string;
    readonly publicKey: Uint8Array;
    readonly publicKeyHash: Uint8Array;
    name: string;
    static readonly signedMessage: SignedMessageI;
    getSeed(): MnemonicI;
    getInfo(): WalletInfoI;
    getPublicKey(hex?: boolean): string | Uint8Array;
    getPublicKeyCompressed(hex?: boolean): string | Uint8Array;
    constructor(name?: string, network?: NetworkType, walletType?: WalletTypeEnum);
    /**
     * fromId - create a wallet from encoded walletId string
     *
     * @param walletId   walletId options to steer the creation process
     *
     * @returns wallet instantiated accordingly to the walletId rules
     */
    static fromId<T extends typeof Wallet>(this: T, walletId: string): Promise<InstanceType<T>>;
    /**
     * fromPrivateKey - create a wallet using the private key supplied in hex or Uint8Array
     *
     * @param wif   WIF encoded private key string
     *
     * @returns instantiated wallet
     */
    static fromPrivateKey<T extends typeof Wallet>(this: T, privateKey: string | Uint8Array): Promise<InstanceType<T>>;
    /**
     * fromWIF - create a wallet using the private key supplied in `Wallet Import Format`
     *
     * @param wif   WIF encoded private key string
     *
     * @returns instantiated wallet
     */
    static fromWIF<T extends typeof Wallet>(this: T, wif: string): Promise<InstanceType<T>>;
    /**
     * fromSeed - create a wallet using the seed phrase and derivation path
     *
     * unless specified the derivation path m/44'/245'/0'/0/0 will be userd
     * this derivation path is standard for Electron Cash SLP and other SLP enabled wallets
     *
     * @param seed   BIP39 12 word seed phrase
     * @param derivationPath BIP44 HD wallet derivation path to get a single the private key from hierarchy
     *
     * @returns instantiated wallet
     */
    static fromSeed<T extends typeof Wallet>(this: T, seed: string, derivationPath?: string): Promise<InstanceType<T>>;
    /**
     * newRandom - create a random wallet
     *
     * if `name` parameter is specified, the wallet will also be persisted to DB
     *
     * @param name   user friendly wallet alias
     * @param dbName name under which the wallet will be stored in the database
     *
     * @returns instantiated wallet
     */
    static newRandom<T extends typeof Wallet>(this: T, name?: string, dbName?: string): Promise<InstanceType<T>>;
    protected generate(): Promise<this>;
    private _generateWif;
    private _generateMnemonic;
    protected fromId: (walletId: string) => Promise<this>;
    getXPubKeys(paths?: any): Promise<any[]>;
    protected fromSeed(mnemonic: string, derivationPath?: string): Promise<this>;
    deriveHdPaths(hdPaths: string[]): Promise<any[]>;
    protected fromPrivateKey(privateKey: string | Uint8Array): Promise<this>;
    protected fromWIF(secret: string): Promise<this>;
    /**
     * newRandom (internal) if the wallet is named, get or create it; otherwise create a random
     * unnamed wallet
     * @param {string} name              name of the wallet
     * @param {string} dbName            database name the wallet is stored in
     */
    protected newRandom(name: string, dbName?: string): Promise<this>;
    toString(): string;
    /**
     * toDbString - store the serialized version of the wallet in the database, not just the name
     *
     * @throws {Error} if called on BaseWallet
     */
    toDbString(): string;
    getMaxAmountToSend(params?: {
        outputCount?: number;
        options?: SendRequestOptionsI;
    }): Promise<BalanceResponse>;
    /**
     * sendMax Send all available funds to a destination cash address
     *
     * @param  {string} cashaddr destination cash address
     * @param  {SendRequestOptionsI} options Options of the send requests
     *
     * @returns (depending on the options parameter) the transaction id, new address balance and a link to the transaction on the blockchain explorer
     */
    sendMax(cashaddr: string, options?: SendRequestOptionsI): Promise<SendResponse>;
    /**
     * encodeTransaction Encode and sign a transaction given a list of sendRequests, options and estimate fees.
     * @param  {SendRequest[]} sendRequests SendRequests
     * @param  {boolean} discardChange=false
     * @param  {SendRequestOptionsI} options Options of the send requests
     */
    encodeTransaction(requests: SendRequest | TokenSendRequest | OpReturnData | Array<SendRequest | TokenSendRequest | OpReturnData> | SendRequestArray[], discardChange?: boolean, options?: SendRequestOptionsI, privateKey?: Uint8Array): Promise<{
        encodedTransaction: Uint8Array;
        tokenIds: string[];
        sourceOutputs: any[];
    }>;
    signUnsignedTransaction(transaction: Uint8Array | string, sourceOutputs: SourceOutput[]): Promise<Uint8Array>;
    private deriveInfo;
    sign(message: string): Promise<import("../message/interface.js").SignedMessageResponseI>;
}
/**
 * Class to manage a testnet wallet.
 */
export declare class TestNetWallet extends Wallet {
    static networkPrefix: CashAddressNetworkPrefix;
    static faucetServer: string;
    constructor(name?: string);
}
/**
 * Class to manage a regtest wallet.
 */
export declare class RegTestWallet extends Wallet {
    static networkPrefix: CashAddressNetworkPrefix;
    constructor(name?: string);
}
/**
 * Class to manage a bitcoin cash wif wallet.
 */
export declare class WifWallet extends Wallet {
    static networkPrefix: CashAddressNetworkPrefix;
    static walletType: WalletTypeEnum;
    constructor(name?: string);
}
/**
 * Class to manage a testnet wif wallet.
 */
export declare class TestNetWifWallet extends Wallet {
    static networkPrefix: CashAddressNetworkPrefix;
    static walletType: WalletTypeEnum;
    constructor(name?: string);
}
/**
 * Class to manage a regtest wif wallet.
 */
export declare class RegTestWifWallet extends Wallet {
    static networkPrefix: CashAddressNetworkPrefix;
    static walletType: WalletTypeEnum;
    constructor(name?: string);
}
//# sourceMappingURL=Wif.d.ts.map