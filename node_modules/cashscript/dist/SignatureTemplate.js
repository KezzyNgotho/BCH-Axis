import { decodePrivateKeyWif, hexToBin, isHex, secp256k1, SigningSerializationFlag } from '@bitauth/libauth';
import { hash256, scriptToBytecode } from '@cashscript/utils';
import { HashType, SignatureAlgorithm, } from './interfaces.js';
import { createSighashPreimage, publicKeyToP2PKHLockingBytecode } from './utils.js';
export default class SignatureTemplate {
    constructor(signer, hashtype = HashType.SIGHASH_ALL | HashType.SIGHASH_UTXOS, signatureAlgorithm = SignatureAlgorithm.SCHNORR) {
        this.hashtype = hashtype;
        this.signatureAlgorithm = signatureAlgorithm;
        if (isKeypair(signer)) {
            const wif = signer.toWIF();
            this.privateKey = decodeWif(wif);
        }
        else if (typeof signer === 'string') {
            const maybeHexString = signer.startsWith('0x') ? signer.slice(2) : signer;
            if (isHex(maybeHexString)) {
                this.privateKey = hexToBin(maybeHexString);
            }
            else {
                this.privateKey = decodeWif(maybeHexString);
            }
        }
        else {
            this.privateKey = signer;
        }
    }
    generateSignature(payload, bchForkId) {
        const signature = this.signMessageHash(payload);
        return Uint8Array.from([...signature, this.getHashType(bchForkId)]);
    }
    signMessageHash(payload) {
        const signature = this.signatureAlgorithm === SignatureAlgorithm.SCHNORR
            ? secp256k1.signMessageHashSchnorr(this.privateKey, payload)
            : secp256k1.signMessageHashDER(this.privateKey, payload);
        return signature;
    }
    getHashType(bchForkId = true) {
        return bchForkId ? (this.hashtype | SigningSerializationFlag.forkId) : this.hashtype;
    }
    getSignatureAlgorithm() {
        return this.signatureAlgorithm;
    }
    getPublicKey() {
        return secp256k1.derivePublicKeyCompressed(this.privateKey);
    }
    unlockP2PKH() {
        const publicKey = this.getPublicKey();
        const prevOutScript = publicKeyToP2PKHLockingBytecode(publicKey);
        const hashtype = this.getHashType();
        return {
            generateLockingBytecode: () => prevOutScript,
            generateUnlockingBytecode: ({ transaction, sourceOutputs, inputIndex }) => {
                const preimage = createSighashPreimage(transaction, sourceOutputs, inputIndex, prevOutScript, hashtype);
                const sighash = hash256(preimage);
                const signature = this.generateSignature(sighash);
                const unlockingBytecode = scriptToBytecode([signature, publicKey]);
                return unlockingBytecode;
            },
            template: this,
        };
    }
}
function isKeypair(obj) {
    return typeof obj.toWIF === 'function';
}
function decodeWif(wif) {
    const result = decodePrivateKeyWif(wif);
    if (typeof result === 'string') {
        throw new Error(result);
    }
    return result.privateKey;
}
//# sourceMappingURL=SignatureTemplate.js.map