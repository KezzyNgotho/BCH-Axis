import { AuthenticationProgramStateResourceLimits, type Transaction } from '@bitauth/libauth';
import type { NetworkProvider } from './network/index.js';
import type SignatureTemplate from './SignatureTemplate.js';
import { Contract } from './Contract.js';
import { AbiFunction } from '@cashscript/utils';
import { FunctionArgument } from './Argument.js';
export interface Utxo {
    txid: string;
    vout: number;
    satoshis: bigint;
    token?: TokenDetails;
}
export interface UnlockableUtxo extends Utxo {
    unlocker: Unlocker;
    options?: InputOptions;
}
export interface StandardUnlockableUtxo extends UnlockableUtxo {
    unlocker: StandardUnlocker;
}
export declare function isUnlockableUtxo(utxo: Utxo): utxo is UnlockableUtxo;
export declare function isStandardUnlockableUtxo(utxo: UnlockableUtxo): utxo is StandardUnlockableUtxo;
export interface InputOptions {
    sequence?: number;
}
export interface GenerateUnlockingBytecodeOptions {
    transaction: Transaction;
    sourceOutputs: LibauthOutput[];
    inputIndex: number;
}
export interface Unlocker {
    generateLockingBytecode: () => Uint8Array;
    generateUnlockingBytecode: (options: GenerateUnlockingBytecodeOptions) => Uint8Array;
}
export interface ContractUnlocker extends Unlocker {
    contract: Contract;
    params: FunctionArgument[];
    abiFunction: AbiFunction;
}
export interface P2PKHUnlocker extends Unlocker {
    template: SignatureTemplate;
}
export type StandardUnlocker = ContractUnlocker | P2PKHUnlocker;
export type PlaceholderP2PKHUnlocker = Unlocker & {
    placeholder: true;
};
export declare function isContractUnlocker(unlocker: Unlocker): unlocker is ContractUnlocker;
export declare function isP2PKHUnlocker(unlocker: Unlocker): unlocker is P2PKHUnlocker;
export declare function isStandardUnlocker(unlocker: Unlocker): unlocker is StandardUnlocker;
export declare function isPlaceholderUnlocker(unlocker: Unlocker): unlocker is PlaceholderP2PKHUnlocker;
export interface Recipient {
    to: string;
    amount: bigint;
    token?: TokenDetails;
}
export interface Output {
    to: string | Uint8Array;
    amount: bigint;
    token?: TokenDetails;
}
export interface TokenDetails {
    amount: bigint;
    category: string;
    nft?: {
        capability: 'none' | 'mutable' | 'minting';
        commitment: string;
    };
}
export interface NftObject {
    category: string;
    capability: 'none' | 'mutable' | 'minting';
    commitment: string;
}
export interface LibauthOutput {
    lockingBytecode: Uint8Array;
    valueSatoshis: bigint;
    token?: LibauthTokenDetails;
}
export interface LibauthTokenDetails {
    amount: bigint;
    category: Uint8Array;
    nft?: {
        capability: 'none' | 'mutable' | 'minting';
        commitment: Uint8Array;
    };
}
export declare enum SignatureAlgorithm {
    ECDSA = 0,
    SCHNORR = 1
}
export declare enum HashType {
    SIGHASH_ALL = 1,
    SIGHASH_NONE = 2,
    SIGHASH_SINGLE = 3,
    SIGHASH_UTXOS = 32,
    SIGHASH_ANYONECANPAY = 128
}
export declare const Network: {
    MAINNET: "mainnet";
    TESTNET3: "testnet3";
    TESTNET4: "testnet4";
    CHIPNET: "chipnet";
    MOCKNET: "mocknet";
    REGTEST: "regtest";
};
export type Network = (typeof Network)[keyof typeof Network];
export declare const VmTarget: {
    BCH_2023_05: "BCH_2023_05";
    BCH_2025_05: "BCH_2025_05";
    BCH_2026_05: "BCH_2026_05";
    BCH_SPEC: "BCH_SPEC";
};
export type VmTarget = (typeof VmTarget)[keyof typeof VmTarget];
export interface TransactionDetails extends Transaction {
    txid: string;
    hex: string;
}
export interface ContractOptions {
    provider: NetworkProvider;
    addressType?: AddressType;
}
export type AddressType = 'p2sh20' | 'p2sh32';
export type VmResourceUsage = AuthenticationProgramStateResourceLimits['metrics'];
