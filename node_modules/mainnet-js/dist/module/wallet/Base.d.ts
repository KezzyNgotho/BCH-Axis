import { CashAddressNetworkPrefix } from "@bitauth/libauth";
import StorageProvider from "../db/StorageProvider.js";
import { NetworkType, UnitEnum } from "../enum.js";
import { TransactionHistoryItem } from "../history/interface.js";
import { HexHeaderI, TxI, UtxoI } from "../interface.js";
import ElectrumNetworkProvider from "../network/ElectrumNetworkProvider.js";
import { ElectrumRawTransaction } from "../network/interface.js";
import { BalanceResponse } from "../util/balanceObjectFromSatoshi.js";
import { WalletTypeEnum } from "./enum.js";
import { CancelFn, SendRequestOptionsI, WaitForTransactionOptions, WaitForTransactionResponse, WalletI, WalletInfoI } from "./interface.js";
import { OpReturnData, SendRequest, SendRequestArray, SendRequestType, SendResponse, TokenBurnRequest, TokenGenesisRequest, TokenMintRequest, TokenSendRequest } from "./model.js";
import { Util } from "./Util.js";
import { Wallet } from "./Wif.js";
/**
 * A class to hold features used by all wallets
 * @class  BaseWallet
 */
export declare class BaseWallet implements WalletI {
    static StorageProvider?: typeof StorageProvider;
    readonly provider: ElectrumNetworkProvider;
    readonly network: NetworkType;
    readonly walletType: WalletTypeEnum;
    _slpSemiAware: boolean;
    readonly publicKeyHash: Uint8Array;
    readonly cashaddr: string;
    readonly tokenaddr: string;
    readonly isTestnet: boolean;
    name: string;
    _util?: Util;
    get networkPrefix(): CashAddressNetworkPrefix;
    get util(): Util;
    static get util(): Util;
    getInfo(): WalletInfoI;
    slpSemiAware(value?: boolean): this;
    protected getNetworkProvider(network?: NetworkType): any;
    /**
     * getDepositAddress - get a wallet deposit address
     *
     * a high-level function,
     *
     * @see {@link https://rest-unstable.mainnet.cash/api-docs/#/wallet/depositAddress|/wallet/deposit_address} for REST endpoint
     *
     * @returns The deposit address as a string
     */
    getDepositAddress(): string;
    /**
     * getTokenDepositAddress - get a cashtoken aware wallet deposit address
     *
     * @returns The cashtoken aware deposit address as a string
     */
    getTokenDepositAddress(): string;
    /**
     * constructor for a new wallet
     * @param network              network for wallet
     *
     * @throws {Error} if called on BaseWallet
     */
    constructor(network?: NetworkType);
    /**
     * watchOnly - create a watch-only wallet
     *
     * such kind of wallet does not have a private key and is unable to spend any funds
     * however it still allows to use many utility functions such as getting and watching balance, etc.
     *
     * @param address   cashaddress, token aware cashaddress of a wallet
     *
     * @returns instantiated wallet
     */
    static watchOnly<T extends typeof BaseWallet>(this: T, address: string): Promise<InstanceType<T>>;
    /**
     * named (internal) get a named wallet from the database or create a new one.
     * Note: this function should behave identically if
     *
     * @param {string} name              name of the wallet
     * @param {string} dbName            database name the wallet is stored in
     * @param {boolean} forceNew         attempt to overwrite an existing wallet
     *
     * @throws {Error} if forceNew is true and the wallet already exists
     * @returns a promise to a named wallet
     */
    protected named(name: string, dbName?: string, forceNew?: boolean): Promise<this>;
    /**
     * replaceNamed - Replace (recover) named wallet with a new walletId
     *
     * If wallet with a provided name does not exist yet, it will be created with a `walletId` supplied
     * If wallet exists it will be overwritten without exception
     *
     * @param name   user friendly wallet alias
     * @param walletId walletId options to steer the creation process
     * @param dbName name under which the wallet will be stored in the database
     *
     * @returns instantiated wallet
     */
    protected replaceNamed(name: string, walletId: string, dbName?: string): Promise<this>;
    /**
     * namedExists - check if a named wallet already exists
     *
     * @param name   user friendly wallet alias
     * @param dbName name under which the wallet will be stored in the database
     *
     * @returns boolean
     */
    protected namedExists(name: string, dbName?: string): Promise<boolean>;
    protected generate(): Promise<this>;
    /**
     * toDbString - store the serialized version of the wallet in the database, not just the name
     *
     * @throws {Error} if called on BaseWallet
     */
    toDbString(): string;
    toString(): string;
    /**
     *  explorerUrl   Web url to a transaction on a block explorer
     *
     * @param txId   transaction Id
     * @returns   Url string
     */
    explorerUrl(txId: string): string;
    getPublicKeyHash(hex?: boolean): string | Uint8Array;
    /**
     * fromCashaddr - create a watch-only wallet in the network derived from the address
     *
     * such kind of wallet does not have a private key and is unable to spend any funds
     * however it still allows to use many utility functions such as getting and watching balance, etc.
     *
     * @param address   cashaddress of a wallet
     *
     * @returns instantiated wallet
     */
    static fromCashaddr<T extends typeof BaseWallet>(this: T, address: string): Promise<InstanceType<T>>;
    /**
     * fromTokenaddr - create a watch-only wallet in the network derived from the address
     *
     * such kind of wallet does not have a private key and is unable to spend any funds
     * however it still allows to use many utility functions such as getting and watching balance, etc.
     *
     * @param address   token aware cashaddress of a wallet
     *
     * @returns instantiated wallet
     */
    static fromTokenaddr<T extends typeof BaseWallet>(this: T, address: string): Promise<InstanceType<T>>;
    /**
     * named - create a named wallet
     *
     * @param name   user friendly wallet alias
     * @param dbName name under which the wallet will be stored in the database
     * @param force  force recreate wallet in the database if a record already exist
     *
     * @returns instantiated wallet
     */
    static named<T extends typeof Wallet>(this: T, name: string, dbName?: string, force?: boolean): Promise<InstanceType<T>>;
    /**
     * replaceNamed - replace (recover) named wallet with a new walletId
     *
     * If wallet with a provided name does not exist yet, it will be created with a `walletId` supplied
     * If wallet exists it will be overwritten without exception
     *
     * @param name   user friendly wallet alias
     * @param walletId walletId options to steer the creation process
     * @param dbName name under which the wallet will be stored in the database
     *
     * @returns instantiated wallet
     */
    static replaceNamed<T extends typeof Wallet>(this: T, name: string, walletId: string, dbName?: string): Promise<InstanceType<T>>;
    /**
     * namedExists - check if a named wallet already exists
     *
     * @param name   user friendly wallet alias
     * @param dbName name under which the wallet will be stored in the database
     *
     * @returns boolean
     */
    static namedExists(name: string, dbName?: string): Promise<boolean>;
    protected fromId(walletId: string): Promise<this>;
    protected watchOnly(address: string): Promise<this>;
    /**
     * utxos Get unspent outputs for the wallet
     *
     */
    getUtxos(): Promise<UtxoI[]>;
    getBalance(rawUnit?: string, priceCache?: boolean): Promise<BalanceResponse | number>;
    getBalanceFromUtxos(): Promise<number>;
    getBalanceFromProvider(): Promise<number>;
    getAddressUtxos(address?: string): Promise<UtxoI[]>;
    watchAddress(callback: (txHash: string) => void): Promise<CancelFn>;
    watchAddressTransactions(callback: (tx: ElectrumRawTransaction) => void): Promise<CancelFn>;
    watchAddressTokenTransactions(callback: (tx: ElectrumRawTransaction) => void): Promise<CancelFn>;
    watchBalance(callback: (balance: BalanceResponse) => void): Promise<CancelFn>;
    watchBalanceUsd(callback: (balance: BalanceResponse) => void, usdPriceRefreshInterval?: number): Promise<CancelFn>;
    waitForBalance(value: number, rawUnit?: UnitEnum): Promise<BalanceResponse>;
    watchTokenBalance(tokenId: string, callback: (balance: bigint) => void): Promise<CancelFn>;
    waitForTokenBalance(tokenId: string, amount: bigint): Promise<bigint>;
    protected _getMaxAmountToSend(params?: {
        outputCount?: number;
        options?: SendRequestOptionsI;
        privateKey?: Uint8Array;
    }): Promise<{
        value: number;
        utxos: UtxoI[];
    }>;
    getMaxAmountToSend(params?: {
        outputCount?: number;
        options?: SendRequestOptionsI;
    }): Promise<BalanceResponse>;
    /**
     * send Send some amount to an address
     * this function processes the send requests, encodes the transaction, sends it to the network
     * @returns (depending on the options parameter) the transaction id, new address balance and a link to the transaction on the blockchain explorer
     *
     * This is a first class function with REST analog, maintainers should strive to keep backward-compatibility
     *
     */
    send(requests: SendRequest | TokenSendRequest | OpReturnData | Array<SendRequest | TokenSendRequest | OpReturnData> | SendRequestArray[], options?: SendRequestOptionsI): Promise<SendResponse>;
    /**
     * sendMax Send all available funds to a destination cash address
     *
     * @param  {string} cashaddr destination cash address
     * @param  {SendRequestOptionsI} options Options of the send requests
     *
     * @returns (depending on the options parameter) the transaction id, new address balance and a link to the transaction on the blockchain explorer
     */
    sendMax(cashaddr: string, options?: SendRequestOptionsI): Promise<SendResponse>;
    /**
     * sendMaxRaw (internal) Send all available funds to a destination cash address
     *
     * @param  {string} cashaddr destination cash address
     * @param  {SendRequestOptionsI} options Options of the send requests
     *
     * @returns the transaction id sent to the network
     */
    protected sendMaxRaw(cashaddr: string, options?: SendRequestOptionsI, privateKey?: Uint8Array): Promise<SendResponse>;
    /**
     * encodeTransaction Encode and sign a transaction given a list of sendRequests, options and estimate fees.
     * @param  {SendRequest[]} sendRequests SendRequests
     * @param  {boolean} discardChange=false
     * @param  {SendRequestOptionsI} options Options of the send requests
     */
    protected encodeTransaction(requests: SendRequest | TokenSendRequest | OpReturnData | Array<SendRequest | TokenSendRequest | OpReturnData> | SendRequestArray[], discardChange?: boolean, options?: SendRequestOptionsI, privateKey?: Uint8Array): Promise<{
        encodedTransaction: Uint8Array;
        tokenIds: string[];
        sourceOutputs: any[];
    }>;
    submitTransaction(transaction: Uint8Array, awaitPropagation?: boolean): Promise<string>;
    getRawHistory(fromHeight?: number, toHeight?: number): Promise<TxI[]>;
    /**
     * getHistory gets transaction history of this wallet with most data decoded and ready to present to user
     * @note balance calculations are valid only if querying to the blockchain tip (`toHeight` === -1, `count` === -1)
     * @note this method is heavy on network calls, if invoked in browser use of cache is advised, @see `Config.UseLocalStorageCache`
     * @note this method tries to recreate the history tab view of Electron Cash wallet, however, it may not be 100% accurate if the tnransaction value changes are the same in the same block (ordering)
     *
     * @param unit optional, BCH or currency unit to present balance and balance changes. If unit is currency like USD or EUR, balances will be subject to possible rounding errors. Default 0
     * @param fromHeight optional, if set, history will be limited. Default 0
     * @param toHeight optional, if set, history will be limited. Default -1, meaning that all history items will be returned, including mempool
     * @param start optional, if set, the result set will be paginated with offset `start`
     * @param count optional, if set, the result set will be paginated with `count`. Default -1, meaning that all history items will be returned
     *
     * @returns an array of transaction history items, with input values and addresses encoded in cashaddress format. @see `TransactionHistoryItem` type
     */
    getHistory({ unit, fromHeight, toHeight, start, count, }: {
        unit?: UnitEnum;
        fromHeight?: number;
        toHeight?: number;
        start?: number;
        count?: number;
    }): Promise<TransactionHistoryItem[]>;
    getLastTransaction(confirmedOnly?: boolean): Promise<ElectrumRawTransaction | null>;
    waitForTransaction(options?: WaitForTransactionOptions): Promise<WaitForTransactionResponse>;
    /**
     * watchBlocks Watch network blocks
     *
     * @param callback callback with a block header object
     * @param skipCurrentHeight if set, the notification about current block will not arrive
     *
     * @returns a function which will cancel watching upon evaluation
     */
    watchBlocks(callback: (header: HexHeaderI) => void, skipCurrentHeight?: boolean): Promise<CancelFn>;
    /**
     * waitForBlock Wait for a network block
     *
     * @param height if specified waits for this exact blockchain height, otherwise resolves with the next block
     *
     */
    waitForBlock(height?: number): Promise<HexHeaderI>;
    verify(message: string, sig: string, publicKey?: Uint8Array): Promise<import("../index.js").VerifyMessageResponseI>;
    /**
     * Create new cashtoken, both funglible and/or non-fungible (NFT)
     * Refer to spec https://github.com/bitjson/cashtokens
     * @param  {number} genesisRequest.amount amount of *fungible* tokens to create
     * @param  {NFTCapability?} genesisRequest.capability capability of new NFT
     * @param  {string?} genesisRequest.commitment NFT commitment message
     * @param  {string?} genesisRequest.cashaddr cash address to send the created token UTXO to; if undefined will default to your address
     * @param  {number?} genesisRequest.value satoshi value to send alongside with tokens; if undefined will default to 1000 satoshi
     * @param  {SendRequestType | SendRequestType[]} sendRequests single or an array of extra send requests (OP_RETURN, value transfer, etc.) to include in genesis transaction
     * @param  {SendRequestOptionsI} options Options of the send requests
     */
    tokenGenesis(genesisRequest: TokenGenesisRequest, sendRequests?: SendRequestType | SendRequestType[], options?: SendRequestOptionsI): Promise<SendResponse>;
    /**
     * Mint new NFT cashtokens using an existing minting token
     * Refer to spec https://github.com/bitjson/cashtokens
     * @param  {string} tokenId tokenId of an NFT to mint
     * @param  {TokenMintRequest | TokenMintRequest[]} mintRequests mint requests with new token properties and recipients
     * @param  {NFTCapability?} mintRequest.capability capability of new NFT
     * @param  {string?} mintRequest.commitment NFT commitment message
     * @param  {string?} mintRequest.cashaddr cash address to send the created token UTXO to; if undefined will default to your address
     * @param  {number?} mintRequest.value satoshi value to send alongside with tokens; if undefined will default to 1000 satoshi
     * @param  {boolean?} deductTokenAmount if minting token contains fungible amount, deduct from it by amount of minted tokens
     * @param  {SendRequestOptionsI} options Options of the send requests
     */
    tokenMint(tokenId: string, mintRequests: TokenMintRequest | Array<TokenMintRequest>, deductTokenAmount?: boolean, options?: SendRequestOptionsI): Promise<SendResponse>;
    /**
     * Perform an explicit token burning by spending a token utxo to an OP_RETURN
     *
     * Behaves differently for fungible and non-fungible tokens:
     *  * NFTs are always "destroyed"
     *  * FTs' amount is reduced by the amount specified, if 0 FT amount is left and no NFT present, the token is "destroyed"
     *
     * Refer to spec https://github.com/bitjson/cashtokens
     * @param  {string} burnRequest.tokenId tokenId of a token to burn
     * @param  {NFTCapability} burnRequest.capability capability of the NFT token to select, optional
     * @param  {string?} burnRequest.commitment commitment of the NFT token to select, optional
     * @param  {number?} burnRequest.amount amount of fungible tokens to burn, optional
     * @param  {string?} burnRequest.cashaddr address to return token and satoshi change to
     * @param  {string?} message optional message to include in OP_RETURN
     * @param  {SendRequestOptionsI} options Options of the send requests
     */
    tokenBurn(burnRequest: TokenBurnRequest, message?: string, options?: SendRequestOptionsI): Promise<SendResponse>;
    /**
     * getTokenUtxos Get unspent token outputs for the wallet
     * will return utxos only for the specified token if `tokenId` provided
     * @param  {string?} tokenId tokenId (category) to filter utxos by, if not set will return utxos from all tokens
     * @returns  {UtxoI[]} token utxos
     */
    getTokenUtxos(tokenId?: string): Promise<UtxoI[]>;
    /**
     * getTokenBalance Gets fungible token balance
     * for NFT token balance see @ref getNftTokenBalance
     * @param  {string} tokenId tokenId to get balance for
     * @returns  {bigint} fungible token balance
     */
    getTokenBalance(tokenId: string): Promise<bigint>;
    /**
     * getNftTokenBalance Gets non-fungible token (NFT) balance for a particular tokenId
     * disregards fungible token balances
     * for fungible token balance see @ref getTokenBalance
     * @param  {string} tokenId tokenId to get balance for
     * @returns  {number} non-fungible token balance
     */
    getNftTokenBalance(tokenId: string): Promise<number>;
    /**
     * getAllTokenBalances Gets all fungible token balances in this wallet
     * @returns  {Object} a map [tokenId => balance] for all tokens in this wallet
     */
    getAllTokenBalances(): Promise<{
        [tokenId: string]: bigint;
    }>;
    /**
     * getAllNftTokenBalances Gets all non-fungible token (NFT) balances in this wallet
     * @returns  {Object} a map [tokenId => balance] for all NFTs in this wallet
     */
    getAllNftTokenBalances(): Promise<{
        [tokenId: string]: number;
    }>;
}
/**
 * Class to manage a mainnet watch wallet.
 */
export declare class WatchWallet extends BaseWallet {
    static networkPrefix: CashAddressNetworkPrefix;
    static walletType: WalletTypeEnum;
    constructor();
}
/**
 * Class to manage a testnet watch wallet.
 */
export declare class TestNetWatchWallet extends BaseWallet {
    static networkPrefix: CashAddressNetworkPrefix;
    static walletType: WalletTypeEnum;
    constructor();
}
/**
 * Class to manage a regtest watch wallet.
 */
export declare class RegTestWatchWallet extends BaseWallet {
    static networkPrefix: CashAddressNetworkPrefix;
    static walletType: WalletTypeEnum;
    constructor();
}
/**
 * getNamedWalletId - get the full wallet id from the database
 *
 * @param name   user friendly wallet alias
 * @param dbName name under which the wallet will be stored in the database
 *
 * @returns boolean
 */
export declare function getNamedWalletId(name: string, dbName?: string): Promise<string | undefined>;
//# sourceMappingURL=Base.d.ts.map