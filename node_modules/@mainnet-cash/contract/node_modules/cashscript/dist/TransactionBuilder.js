import { binToHex, decodeTransaction, decodeTransactionUnsafe, encodeTransaction, hexToBin, } from '@bitauth/libauth';
import { isUnlockableUtxo, isStandardUnlockableUtxo, isP2PKHUnlocker, } from './interfaces.js';
import { cashScriptOutputToLibauthOutput, createOpReturnOutput, delay, generateLibauthSourceOutputs, validateInput, validateOutput, } from './utils.js';
import { FailedTransactionError } from './Errors.js';
import { getBitauthUri } from './LibauthTemplate.js';
import { debugLibauthTemplate, getLibauthTemplates } from './advanced/LibauthTemplate.js';
import { getWcContractInfo } from './walletconnect-utils.js';
import semver from 'semver';
const DEFAULT_SEQUENCE = 0xfffffffe;
export class TransactionBuilder {
    constructor(options) {
        this.inputs = [];
        this.outputs = [];
        this.locktime = 0;
        this.provider = options.provider;
    }
    addInput(utxo, unlocker, options) {
        return this.addInputs([utxo], unlocker, options);
    }
    addInputs(utxos, unlocker, options) {
        utxos.forEach(validateInput);
        if ((!unlocker && utxos.some((utxo) => !isUnlockableUtxo(utxo)))
            || (unlocker && utxos.some((utxo) => isUnlockableUtxo(utxo)))) {
            throw new Error('Either all UTXOs must have an individual unlocker specified, or no UTXOs must have an individual unlocker specified and a shared unlocker must be provided');
        }
        if (!unlocker) {
            this.inputs = this.inputs.concat(utxos);
            return this;
        }
        this.inputs = this.inputs.concat(utxos.map(((utxo) => ({ ...utxo, unlocker, options }))));
        return this;
    }
    addOutput(output) {
        return this.addOutputs([output]);
    }
    addOutputs(outputs) {
        outputs.forEach(validateOutput);
        this.outputs = this.outputs.concat(outputs);
        return this;
    }
    // TODO: allow uint8array for chunks
    addOpReturnOutput(chunks) {
        this.outputs.push(createOpReturnOutput(chunks));
        return this;
    }
    setLocktime(locktime) {
        this.locktime = locktime;
        return this;
    }
    setMaxFee(maxFee) {
        this.maxFee = maxFee;
        return this;
    }
    checkMaxFee() {
        if (!this.maxFee)
            return;
        const totalInputAmount = this.inputs.reduce((total, input) => total + input.satoshis, 0n);
        const totalOutputAmount = this.outputs.reduce((total, output) => total + output.amount, 0n);
        const fee = totalInputAmount - totalOutputAmount;
        if (fee > this.maxFee) {
            throw new Error(`Transaction fee of ${fee} is higher than max fee of ${this.maxFee}`);
        }
    }
    buildLibauthTransaction() {
        this.checkMaxFee();
        const inputs = this.inputs.map((utxo) => ({
            outpointIndex: utxo.vout,
            outpointTransactionHash: hexToBin(utxo.txid),
            sequenceNumber: utxo.options?.sequence ?? DEFAULT_SEQUENCE,
            unlockingBytecode: new Uint8Array(),
        }));
        const outputs = this.outputs.map(cashScriptOutputToLibauthOutput);
        const transaction = {
            inputs,
            locktime: this.locktime,
            outputs,
            version: 2,
        };
        // Generate source outputs from inputs (for signing with SIGHASH_UTXOS)
        const sourceOutputs = generateLibauthSourceOutputs(this.inputs);
        const inputScripts = this.inputs.map((input, inputIndex) => (input.unlocker.generateUnlockingBytecode({ transaction, sourceOutputs, inputIndex })));
        inputScripts.forEach((script, i) => {
            transaction.inputs[i].unlockingBytecode = script;
        });
        return transaction;
    }
    build() {
        const transaction = this.buildLibauthTransaction();
        return binToHex(encodeTransaction(transaction));
    }
    debug() {
        // do not debug a pure P2PKH-spend transaction
        if (this.inputs.every((input) => isP2PKHUnlocker(input.unlocker))) {
            return {};
        }
        if (this.inputs.some((input) => !isStandardUnlockableUtxo(input))) {
            throw new Error('Cannot debug a transaction with custom unlocker');
        }
        // We can typecast this because we check that all inputs are standard unlockable in the check above
        const contractVersions = this.inputs
            .map((input) => 'contract' in input.unlocker ? input.unlocker.contract.artifact.compiler.version : null)
            .filter((version) => version !== null);
        if (!contractVersions.every((version) => semver.satisfies(version, '>=0.11.0'))) {
            console.warn('For the best debugging experience, please recompile your contract with cashc version 0.11.0 or newer.');
        }
        return debugLibauthTemplate(this.getLibauthTemplate(), this);
    }
    bitauthUri() {
        console.warn('WARNING: it is unsafe to use this Bitauth URI when using real private keys as they are included in the transaction template');
        return getBitauthUri(this.getLibauthTemplate());
    }
    getLibauthTemplate() {
        return getLibauthTemplates(this);
    }
    async send(raw) {
        const tx = this.build();
        // If all inputs are standard unlockable, we can debug the transaction locally
        // before sending so any errors are caught early
        if (this.inputs.every((input) => isStandardUnlockableUtxo(input))) {
            this.debug();
        }
        try {
            const txid = await this.provider.sendRawTransaction(tx);
            return raw ? await this.getTxDetails(txid, raw) : await this.getTxDetails(txid);
        }
        catch (e) {
            const reason = e.error ?? e.message;
            throw new FailedTransactionError(reason);
        }
    }
    async getTxDetails(txid, raw) {
        for (let retries = 0; retries < 1200; retries += 1) {
            await delay(500);
            try {
                const hex = await this.provider.getRawTransaction(txid);
                if (raw)
                    return hex;
                const libauthTransaction = decodeTransaction(hexToBin(hex));
                return { ...libauthTransaction, txid, hex };
            }
            catch (ignored) {
                // ignored
            }
        }
        // Should not happen
        throw new Error('Could not retrieve transaction details for over 10 minutes');
    }
    generateWcTransactionObject(options) {
        const encodedTransaction = this.build();
        const transaction = decodeTransactionUnsafe(hexToBin(encodedTransaction));
        const libauthSourceOutputs = generateLibauthSourceOutputs(this.inputs);
        const sourceOutputs = libauthSourceOutputs.map((sourceOutput, index) => {
            return {
                ...sourceOutput,
                ...transaction.inputs[index],
                ...getWcContractInfo(this.inputs[index]),
            };
        });
        return { ...options, transaction, sourceOutputs };
    }
}
//# sourceMappingURL=TransactionBuilder.js.map