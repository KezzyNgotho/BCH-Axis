import { binToHex } from '@bitauth/libauth';
import { sha256 } from '@cashscript/utils';
import { ElectrumClient, } from '@electrum-cash/network';
import { Network } from '../interfaces.js';
import { addressToLockScript } from '../utils.js';
export default class ElectrumNetworkProvider {
    constructor(network = Network.MAINNET, options = {}) {
        this.network = network;
        this.concurrentRequests = 0;
        this.electrum = this.instantiateElectrumClient(network, options);
        this.manualConnectionManagement = options?.manualConnectionManagement ?? false;
    }
    instantiateElectrumClient(network, options) {
        if ('electrum' in options)
            return options.electrum;
        const server = 'hostname' in options ? options.hostname : this.getServerForNetwork(network);
        return new ElectrumClient('CashScript Application', '1.4.1', server, { disableBrowserVisibilityHandling: true });
    }
    // Get Electrum server based on network
    getServerForNetwork(network) {
        switch (network) {
            case Network.MAINNET:
                return 'bch.imaginary.cash';
            case Network.TESTNET3:
                return 'testnet.imaginary.cash';
            case Network.TESTNET4:
                return 'testnet4.imaginary.cash';
            case Network.CHIPNET:
                return 'chipnet.bch.ninja';
            default:
                throw new Error(`Unsupported network: ${network}`);
        }
    }
    async getUtxos(address) {
        const scripthash = addressToElectrumScriptHash(address);
        const filteringOption = 'include_tokens';
        const result = await this.performRequest('blockchain.scripthash.listunspent', scripthash, filteringOption);
        const utxos = result.map((utxo) => ({
            txid: utxo.tx_hash,
            vout: utxo.tx_pos,
            satoshis: BigInt(utxo.value),
            token: utxo.token_data ? {
                ...utxo.token_data,
                amount: BigInt(utxo.token_data.amount),
            } : undefined,
        }));
        return utxos;
    }
    async getBlockHeight() {
        const { height } = await this.performRequest('blockchain.headers.subscribe');
        return height;
    }
    async getRawTransaction(txid) {
        return await this.performRequest('blockchain.transaction.get', txid);
    }
    async sendRawTransaction(txHex) {
        return await this.performRequest('blockchain.transaction.broadcast', txHex);
    }
    async connect() {
        if (!this.manualConnectionManagement) {
            throw new Error('Manual connection management is disabled');
        }
        return this.electrum.connect();
    }
    async disconnect() {
        if (!this.manualConnectionManagement) {
            throw new Error('Manual connection management is disabled');
        }
        return this.electrum.disconnect();
    }
    async performRequest(name, ...parameters) {
        // Only connect the electrum client when no concurrent requests are running
        if (this.shouldConnect()) {
            await this.electrum.connect();
        }
        this.concurrentRequests += 1;
        let result;
        try {
            result = await this.electrum.request(name, ...parameters);
        }
        finally {
            // Always disconnect the electrum client, also if the request fails
            // as long as no other concurrent requests are running
            if (this.shouldDisconnect()) {
                await this.electrum.disconnect();
            }
        }
        this.concurrentRequests -= 1;
        if (result instanceof Error)
            throw result;
        return result;
    }
    shouldConnect() {
        if (this.manualConnectionManagement)
            return false;
        if (this.concurrentRequests !== 0)
            return false;
        return true;
    }
    shouldDisconnect() {
        if (this.manualConnectionManagement)
            return false;
        if (this.concurrentRequests !== 1)
            return false;
        return true;
    }
}
/**
 * Helper function to convert an address to an electrum-cash compatible scripthash.
 * This is necessary to support electrum versions lower than 1.4.3, which do not
 * support addresses, only script hashes.
 *
 * @param address Address to convert to an electrum scripthash
 *
 * @returns The corresponding script hash in an electrum-cash compatible format
 */
function addressToElectrumScriptHash(address) {
    // Retrieve locking script
    const lockScript = addressToLockScript(address);
    // Hash locking script
    const scriptHash = sha256(lockScript);
    // Reverse scripthash
    scriptHash.reverse();
    // Return scripthash as a hex string
    return binToHex(scriptHash);
}
//# sourceMappingURL=ElectrumNetworkProvider.js.map