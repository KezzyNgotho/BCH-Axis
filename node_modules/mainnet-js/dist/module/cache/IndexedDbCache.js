// super thin wrapper around indexedDB, compatible with localStorage API
export class IndexedDbCache {
    constructor(objectStoreName = "ElectrumNetworkProviderCache") {
        this.objectStoreName = objectStoreName;
        this.db = null;
        this.objectStoreName = objectStoreName;
    }
    getDatabaseObjectFromTarget(target) {
        if (!target) {
            return null;
        }
        const targetWithType = target;
        return targetWithType.result;
    }
    throwDatabaseOpenError(reject, database) {
        if (!database) {
            reject(new Error("Something went wrong and the database transaction was not opened."));
        }
    }
    async init() {
        const db = indexedDB.open("ElectrumNetworkProviderCache", 1);
        this.db = await new Promise((resolve, reject) => {
            const request = db;
            request.onerror = reject;
            request.onsuccess = ({ target }) => {
                const database = this.getDatabaseObjectFromTarget(target);
                this.throwDatabaseOpenError(reject, database);
                resolve(database);
            };
            request.onupgradeneeded = ({ target }) => {
                const database = this.getDatabaseObjectFromTarget(target);
                this.throwDatabaseOpenError(reject, database);
                database?.createObjectStore(this.objectStoreName);
            };
        });
    }
    async setItem(key, value) {
        if (!this.db) {
            throw new Error("Database is not initialized");
        }
        const transaction = this.db.transaction(this.objectStoreName, "readwrite");
        const objectStore = transaction.objectStore(this.objectStoreName);
        return new Promise((resolve, reject) => {
            const request = objectStore.put(value, key);
            request.onerror = reject;
            request.onsuccess = () => resolve();
        });
    }
    async getItem(key) {
        if (!this.db) {
            throw new Error("Database is not initialized");
        }
        const transaction = this.db.transaction(this.objectStoreName, "readonly");
        const objectStore = transaction.objectStore(this.objectStoreName);
        return new Promise((resolve, reject) => {
            const request = objectStore.get(key);
            request.onerror = reject;
            request.onsuccess = () => resolve(request.result ?? null);
        });
    }
    async removeItem(key) {
        if (!this.db) {
            throw new Error("Database is not initialized");
        }
        const transaction = this.db.transaction(this.objectStoreName, "readwrite");
        const objectStore = transaction.objectStore(this.objectStoreName);
        return new Promise((resolve, reject) => {
            const request = objectStore.delete(key);
            request.onerror = reject;
            request.onsuccess = () => resolve();
        });
    }
    async clear() {
        if (!this.db) {
            throw new Error("Database is not initialized");
        }
        const transaction = this.db.transaction(this.objectStoreName, "readwrite");
        const objectStore = transaction.objectStore(this.objectStoreName);
        return new Promise((resolve, reject) => {
            const request = objectStore.clear();
            request.onerror = reject;
            request.onsuccess = () => resolve();
        });
    }
}
//# sourceMappingURL=IndexedDbCache.js.map